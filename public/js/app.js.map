{"version":3,"names":[],"mappings":"","sources":["app.js"],"sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      }\n      throw TypeError('Uncaught, unspecified \"error\" event.');\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        len = arguments.length;\n        args = new Array(len - 1);\n        for (i = 1; i < len; i++)\n          args[i - 1] = arguments[i];\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    len = arguments.length;\n    args = new Array(len - 1);\n    for (i = 1; i < len; i++)\n      args[i - 1] = arguments[i];\n\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    var m;\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  var ret;\n  if (!emitter._events || !emitter._events[type])\n    ret = 0;\n  else if (isFunction(emitter._events[type]))\n    ret = 1;\n  else\n    ret = emitter._events[type].length;\n  return ret;\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n},{}],2:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\n// prefix of api url\nvar ApiPrefix = '/api',\n    PostConst = {\n\n    LOAD_ALL: 'POST_LOAD_ALL',\n    CREATE: 'POST_CREATE'\n};\n\nexports.ApiPrefix = ApiPrefix;\nexports.PostConst = PostConst;\n\n},{}],3:[function(require,module,exports){\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Dispatcher = function () {\n    function Dispatcher() {\n        _classCallCheck(this, Dispatcher);\n\n        this._callbacks = {};\n        this._isDispatching = false;\n        this._isHandled = {};\n        this._actionFired = {};\n        this._isPending = {};\n        this._lastID = 1;\n        this._prefix = 'ID_';\n    }\n\n    /**\n     * Registers a callback to be invoked with every dispatched payload. Returns\n     * a token that can be used with `waitFor()`.\n     */\n\n    _createClass(Dispatcher, [{\n        key: 'register',\n        value: function register(callback) {\n            var id = this._prefix + this._lastID++;\n            this._callbacks[id] = callback;\n            return id;\n        }\n\n        /**\n         * Removes a callback based on its token.\n         */\n\n    }, {\n        key: 'unregister',\n        value: function unregister(id) {\n            delete this._callbacks[id];\n        }\n\n        /**\n         * Is this Dispatcher currently dispatching.\n         */\n\n    }, {\n        key: 'isDispatching',\n        value: function isDispatching() {\n            return this._isDispatching;\n        }\n\n        /**\n         * Call the callback stored with the given id. Also do some internal\n         * bookkeeping.\n         *\n         * @internal\n         */\n\n    }, {\n        key: '_invokeCallback',\n        value: function _invokeCallback(id) {\n            this._isPending[id] = true;\n            this._callbacks[id](this._pendingPayload);\n            this._isHandled[id] = true;\n        }\n\n        /**\n         * Set up bookkeeping needed when dispatching.\n         *\n         * @internal\n         */\n\n    }, {\n        key: '_startDispatching',\n        value: function _startDispatching(payload) {\n            for (var id in this._callbacks) {\n                this._isPending[id] = false;\n                this._isHandled[id] = false;\n            }\n            this._pendingPayload = payload;\n            this._isDispatching = true;\n        }\n\n        /**\n         * Clear bookkeeping used for dispatching.\n         *\n         * @internal\n         */\n\n    }, {\n        key: '_stopDispatching',\n        value: function _stopDispatching() {\n            delete this._pendingPayload;\n            this._isDispatching = false;\n        }\n\n        /**\n         * Dispatches a payload to all registered callbacks.\n         */\n\n    }, {\n        key: 'dispatch',\n        value: function dispatch(payload) {\n\n            this._startDispatching(payload);\n            try {\n                for (var id in this._callbacks) {\n                    if (this._isPending[id]) {\n                        continue;\n                    }\n                    this._invokeCallback(id);\n                }\n            } finally {\n                this._stopDispatching();\n            }\n        }\n    }]);\n\n    return Dispatcher;\n}();\n\nexports.default = new Dispatcher();\n\n},{}],4:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _Post = require(\"./components/Post\");\n\nvar _Post2 = _interopRequireDefault(_Post);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Router = ReactRouter.Router;\nvar Route = ReactRouter.Route;\nvar IndexRoute = ReactRouter.IndexRoute;\nvar BrowserHistory = ReactRouter.browserHistory;\n\nvar routesMap = React.createElement(\n    Router,\n    { history: BrowserHistory },\n    React.createElement(Route, { path: \"/\", component: _Post2.default })\n);\n\nexports.default = routesMap;\n\n},{\"./components/Post\":7}],5:[function(require,module,exports){\n\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _Constant = require(\"../Constant\");\n\nvar _Dispatcher = require(\"../Dispatcher\");\n\nvar _Dispatcher2 = _interopRequireDefault(_Dispatcher);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar PostAction = function () {\n    function PostAction() {\n        _classCallCheck(this, PostAction);\n    }\n\n    _createClass(PostAction, [{\n        key: \"loadAll\",\n        value: function loadAll() {\n\n            _Dispatcher2.default.dispatch({\n                type: _Constant.PostConst.LOAD_ALL\n            });\n        }\n    }, {\n        key: \"create\",\n        value: function create(name, title) {\n            _Dispatcher2.default.dispatch({\n                type: _Constant.PostConst.CREATE,\n                name: name,\n                title: title\n            });\n        }\n    }]);\n\n    return PostAction;\n}();\n\nexports.default = new PostAction();\n\n},{\"../Constant\":2,\"../Dispatcher\":3}],6:[function(require,module,exports){\n'use strict';\n\nvar _Route = require('./Route');\n\nvar _Route2 = _interopRequireDefault(_Route);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nif (typeof __SERVER === 'undefined') {\n    ReactDOM.render(_Route2.default, document.getElementById(\"main\"));\n}\n\n},{\"./Route\":4}],7:[function(require,module,exports){\n\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _PostStore = require(\"../stores/PostStore\");\n\nvar _PostStore2 = _interopRequireDefault(_PostStore);\n\nvar _PostAction = require(\"../actions/PostAction\");\n\nvar _PostAction2 = _interopRequireDefault(_PostAction);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Post = function (_React$Component) {\n    _inherits(Post, _React$Component);\n\n    function Post() {\n        _classCallCheck(this, Post);\n\n        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Post).call(this));\n\n        _this.state = {\n            posts: []\n        };\n        _this._onChange = _this._onChange.bind(_this);\n        return _this;\n    }\n\n    _createClass(Post, [{\n        key: \"componentDidMount\",\n        value: function componentDidMount() {\n            _PostStore2.default.addChangeListener(this._onChange);\n\n            // if there is updated in data, _onChange will be fired and data will be updated\n            _PostStore2.default.loadAll();\n        }\n    }, {\n        key: \"componentWillUnmount\",\n        value: function componentWillUnmount() {\n            this.ws.close();\n            _PostStore2.default.removeChangeListener(this._onChange);\n        }\n    }, {\n        key: \"_onChange\",\n        value: function _onChange() {\n            this.setState({\n                posts: _PostStore2.default.getAll()\n            });\n        }\n    }, {\n        key: \"_nameOnChange\",\n        value: function _nameOnChange(e) {\n            this.setState({\n                name: e.target.value\n            });\n        }\n    }, {\n        key: \"_titleOnChange\",\n        value: function _titleOnChange(e) {\n            this.setState({\n                title: e.target.value\n            });\n        }\n    }, {\n        key: \"_onSubmit\",\n        value: function _onSubmit(e) {\n            e.preventDefault();\n\n            var name = this.state.name;\n            var title = this.state.title;\n\n            this.setState({ name: \"\", title: \"\" });\n\n            _PostAction2.default.create(name, title);\n        }\n    }, {\n        key: \"render\",\n        value: function render() {\n\n            var list = [];\n            for (var i = 0; i < this.state.posts.length; i++) {\n                var post = this.state.posts[i];\n\n                list.push(React.createElement(\n                    \"li\",\n                    { key: i },\n                    post.title,\n                    \" \",\n                    React.createElement(\n                        \"small\",\n                        null,\n                        \"by \",\n                        post.name\n                    )\n                ));\n            }\n\n            return React.createElement(\n                \"div\",\n                null,\n                React.createElement(\n                    \"p\",\n                    null,\n                    \"Comment page\"\n                ),\n                React.createElement(\n                    \"ul\",\n                    null,\n                    list\n                ),\n                React.createElement(\n                    \"form\",\n                    { onSubmit: this._onSubmit.bind(this) },\n                    React.createElement(\"input\", { value: this.state.name, onChange: this._nameOnChange.bind(this), placeholder: \"name\" }),\n                    React.createElement(\"input\", { value: this.state.title, onChange: this._titleOnChange.bind(this), placeholder: \"title\" }),\n                    React.createElement(\"input\", { type: \"submit\", value: \"送信\" })\n                )\n            );\n        }\n    }]);\n\n    return Post;\n}(React.Component);\n\nexports.default = Post;\n\n},{\"../actions/PostAction\":5,\"../stores/PostStore\":9}],8:[function(require,module,exports){\n\"use strict\";\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _events = require(\"events\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar CHANGE_EVENT = \"change\";\n\nvar BaseStore = function (_EventEmitter) {\n    _inherits(BaseStore, _EventEmitter);\n\n    function BaseStore() {\n        _classCallCheck(this, BaseStore);\n\n        return _possibleConstructorReturn(this, Object.getPrototypeOf(BaseStore).call(this));\n    }\n\n    _createClass(BaseStore, [{\n        key: \"emitChange\",\n        value: function emitChange() {\n            this.emit(CHANGE_EVENT);\n        }\n\n        /**\n         * @param {function} callback\n         */\n\n    }, {\n        key: \"addChangeListener\",\n        value: function addChangeListener(callback) {\n            this.on(CHANGE_EVENT, callback);\n        }\n\n        /**\n         * @param {function} callback\n         */\n\n    }, {\n        key: \"removeChangeListener\",\n        value: function removeChangeListener(callback) {\n            this.removeListener(CHANGE_EVENT, callback);\n        }\n    }, {\n        key: \"ajax\",\n        value: function ajax(method, path, cb, data) {\n\n            var xhr = null;\n            try {\n                xhr = new XMLHttpRequest();\n            } catch (e) {\n                try {\n                    xhr = new ActiveXObject(\"Msxml2.XMLHTTP\");\n                } catch (e) {\n                    console.log(\"tinyxhr: XMLHttpRequest not supported\");\n                    return null;\n                }\n            }\n\n            xhr.open(method.toUpperCase(), path);\n            xhr.onreadystatechange = function () {\n                if (xhr.readyState != 4) return;\n\n                var res = JSON.parse(xhr.responseText);\n                var error = false;\n                if (xhr.status !== 200) {\n                    error = true;\n                }\n                cb(error, res, xhr.status);\n            };\n\n            var getParams = function getParams(data, url) {\n                var arr = [],\n                    str;\n                for (var name in data) {\n                    if (Array.isArray(data[name])) {\n                        var arrayData = data[name];\n                        for (var i = 0; i < arrayData.length; i++) {\n                            arr.push(name + \"[]\" + '=' + encodeURIComponent(arrayData[i]));\n                        }\n                    } else {\n                        arr.push(name + '=' + encodeURIComponent(data[name]));\n                    }\n                }\n                str = arr.join('&');\n                if (str != '') {\n                    return url ? url.indexOf('?') < 0 ? '?' + str : '&' + str : str;\n                }\n                return '';\n            };\n\n            var formData = null;\n            if ((typeof data === \"undefined\" ? \"undefined\" : _typeof(data)) === 'object') {\n\n                xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');\n                formData = getParams(data);\n            }\n\n            xhr.send(formData);\n        }\n    }]);\n\n    return BaseStore;\n}(_events.EventEmitter);\n\nexports.default = BaseStore;\n\n},{\"events\":1}],9:[function(require,module,exports){\n\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _Constant = require(\"../Constant\");\n\nvar _Dispatcher = require(\"../Dispatcher\");\n\nvar _Dispatcher2 = _interopRequireDefault(_Dispatcher);\n\nvar _BaseStore2 = require(\"./BaseStore\");\n\nvar _BaseStore3 = _interopRequireDefault(_BaseStore2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar PostStore = function (_BaseStore) {\n    _inherits(PostStore, _BaseStore);\n\n    /**\n     * constructor\n     */\n\n    function PostStore() {\n        _classCallCheck(this, PostStore);\n\n        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(PostStore).call(this));\n\n        _this.data = [];\n\n        _this.dispatchToken = _Dispatcher2.default.register(function (action) {\n            switch (action.type) {\n                case _Constant.PostConst.LOAD_ALL:\n                    _this.loadAll();\n                    break;\n                case _Constant.PostConst.CREATE:\n                    _this.create(action.name, action.title);\n                    break;\n            }\n        });\n        return _this;\n    }\n\n    _createClass(PostStore, [{\n        key: \"loadAll\",\n        value: function loadAll() {\n            var _this2 = this;\n\n            this.ajax(\"get\", _Constant.ApiPrefix + \"/post\", function (error, data) {\n                _this2.data = data;\n                _this2.emitChange();\n            });\n        }\n    }, {\n        key: \"create\",\n        value: function create(name, title) {\n            var _this3 = this;\n\n            var formData = {\n                name: name,\n                title: title\n            };\n\n            this.ajax(\"post\", _Constant.ApiPrefix + \"/post\", function (error, post) {\n                _this3.data.push(post);\n                _this3.emitChange();\n            }, formData);\n        }\n    }, {\n        key: \"getAll\",\n        value: function getAll() {\n            return this.data;\n        }\n    }]);\n\n    return PostStore;\n}(_BaseStore3.default);\n\nexports.default = new PostStore();\n\n},{\"../Constant\":2,\"../Dispatcher\":3,\"./BaseStore\":8}]},{},[6]);\n"],"file":"app.js","sourceRoot":"/source/"}